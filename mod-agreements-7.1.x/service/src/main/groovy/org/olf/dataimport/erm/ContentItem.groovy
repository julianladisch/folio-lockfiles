package org.olf.dataimport.erm

import java.time.LocalDate
import javax.validation.constraints.NotNull
import org.olf.dataimport.internal.PackageSchema.ContentItemSchema
import org.olf.dataimport.internal.PackageSchema.IdentifierSchema
import org.olf.kb.AbstractCoverageStatement

import grails.compiler.GrailsCompileStatic
import grails.validation.Validateable
import groovy.transform.Memoized
import groovy.transform.ToString

import org.springframework.validation.Errors

@ToString(includePackage=false)
@GrailsCompileStatic
class ContentItem implements ContentItemSchema, Validateable {
  
  String note
  String sourceIdentifier
  String sourceIdentifierNamespace
  String depth
  LocalDate accessStart
  LocalDate accessEnd
  String embargo

  Long removedTimestamp

  // Must NOT have items of its own
  ErmPackageImpl contentItemPackage
  
  Set<CoverageStatement> coverage
  
  PlatformTitileInstance platformTitleInstance
  
  static hasMany = [
    coverage: CoverageStatement
  ]
  
  /* As far as I can tell, this validation isn't actually ever fired for the import process.
   * This is fine, since in general we validate the actual domain objects we
   * save to the db, but it does potentially leave space for optimisation if we can catch some
   * failures earlier.
   *
   * The newer "pushKB" process will call a validate, so extra validators have been added
   * to PackageContentImpl to allow fields that _ARE_ nullable, but were never previously
   * validated, so were presumed non-nullable. Those may need to be copied over here if we
    * turn on validate for this schema in future.
   */
  static constraints = {
    sourceIdentifier nullable: false, blank: false
    sourceIdentifierNamespace nullable: false, blank: false
    note          nullable: true, blank: false
    depth         nullable: true, blank: false
    accessStart nullable:true, validator: { LocalDate startDate, ContentItemSchema item ->
      if (!startDate && item.accessEnd) {
        return ['null.message']
      }
    }
    
    accessEnd nullable:true, validator: { LocalDate endDate, ContentItemSchema item ->
      
      if (item.accessStart &&
        endDate &&
        ( item.accessStart > endDate) ) {
          return [ 'start.after.end', 'accessStart', item.class.name, item.accessStart, endDate]
      }
    }

    contentItemPackage validator: {ErmPackageImpl pkg, ContentItemSchema item, Errors errors ->
      if ((pkg?.contentItems ?: []).size() > 0) {
        errors.rejectValue('contentItemPackage', 'contentItemPackage.has.items')
      }
    }

    coverage (validator: AbstractCoverageStatement.STATEMENT_COLLECTION_VALIDATOR, sort:'startDate')
    platformTitleInstance nullable: false
  }

  @Override
  public String getTitle() {
    platformTitleInstance?.titleInstance?.name
  }
  
  @Override
  public String getInstanceMedium() {
    platformTitleInstance?.titleInstance?.subType
  }
  
  @Override
  public String getInstanceMedia() {
    platformTitleInstance?.titleInstance?.type
  }

  @Override
  public String getInstancePublicationMedia() {
    platformTitleInstance?.titleInstance?.publicationType
  }
  
  private static final Map<String,List<String>> known_id_types = [
    // ERM-1649 Allow this to collect all possible incoming siblings so we can match on them in the citation
    electronic : ['EISSN', 'DOI', 'EZB'],
    print : ['ISSN', 'PISSN']
  ]
  
  // Return all namespaces from known_id_types that are NOT listed under the given subType.
  @Memoized
  private final Collection<String> siblingNamespacesForSubType (@NotNull final String subType) {
    final Set<String> all = []
    known_id_types.each { final String type, final List<String> namespaces ->
      if (type.trim().toLowerCase() != subType.trim().toLowerCase()) {
        all.addAll namespaces
      }
    }
    
    all
  }  
  
  // Return all instance identifiers on the PTI's TI where the namespace is not found in the list generated by siblingNamespacesForSubType
  @Override
  public Collection<IdentifierSchema> getInstanceIdentifiers() {
    Collection<IdentifierSchema> ids = platformTitleInstance?.titleInstance?.identifiers as Collection<IdentifierSchema>
    
    def siblings = instanceMedium ? siblingNamespacesForSubType(instanceMedium) : []
    
    ids && siblings ? ids.findAll { IdentifierSchema idSch -> !siblings.contains(idSch.namespace.trim().toUpperCase()) } as Collection<IdentifierSchema> : ids
  }
  
  // Return all instance identifiers on the PTI's TI where the namespace is found in the list generated by siblingNamespacesForSubType
  @Override
  public Collection<IdentifierSchema> getSiblingInstanceIdentifiers() {
    Collection<IdentifierSchema> ids = platformTitleInstance?.titleInstance?.identifiers as Collection<IdentifierSchema>
    
    def siblings = instanceMedium ? siblingNamespacesForSubType(instanceMedium) : []
    
    ids && siblings ? ids.findAll { IdentifierSchema idSch -> siblings.contains(idSch.namespace.trim().toUpperCase()) } as Collection<IdentifierSchema> : ids
  }
  
  @Override
  public String getCoverageDepth() {
    depth
  }
  
  @Override
  public String getCoverageNote() {
    note
  }

  @Override
  public String getSourceIdentifier() {
    sourceIdentifier
  }

  @Override
  public String getSourceIdentifierNamespace() {
    sourceIdentifierNamespace
  }
  
  @Override
  public String getPlatformUrl() {
    platformTitleInstance?.platformUrl
  }
  
  @Override
  public String getPlatformName() {
    platformTitleInstance?.platform
  }

  @Override
  public LocalDate getAccessStart() {
    accessStart
  }

  @Override
  public LocalDate getAccessEnd() {
    accessEnd
  }

  @Override
  public Long getRemovedTimestamp() {
    removedTimestamp
  }

  @Override
  public String get_platformId() {
    // Null for this implementation
    null
  }

  @Override
  public String getUrl() {
    platformTitleInstance.url
  }

  @Override
  public String getDateMonographPublished() {
    platformTitleInstance?.titleInstance?.dateMonographPublished
  }

  @Override
  public String getFirstAuthor() {
    platformTitleInstance?.titleInstance?.firstAuthor
  }

  @Override
  public String getFirstEditor() {
    platformTitleInstance?.titleInstance?.firstEditor
  }

  @Override
  public String getMonographEdition() {
    platformTitleInstance?.titleInstance?.monographEdition
  }

  @Override
  public String getMonographVolume() {
    platformTitleInstance?.titleInstance?.monographVolume
  }
}
